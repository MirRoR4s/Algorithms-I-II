# Video: Quick-Union

在实践中，它实际上是很好的。 flattening actually in practice that it actually is just about as good. 因此，只需一行代码，我们就可以使树几乎完全平坦。  So, with one line of code, we can keep the trees almost completely flat. 人们很早就发现了这个算法在计算出权重之后它的分析非常有趣超出了我们的范围。  Now, this algorithm people discovered rather early on after figuring out the weighting and it turns out to be fascinating to analyze quite beyond our scope. 但我们提到这个例子是为了说明即使是一个简单的算法，也可以有有趣和复杂的分析。  But we mentioned this example to illustrate how even a simple algorithmah, can have interesting and complex analysis. Hopcroft Ulman和Tarjan证明了如果你有N个对象，任何M个并集和查找操作序列最多会碰到数组c (N + mlg star N)次。  And what was proved by Hopcroft Ulman and Tarjan was that if you have N objects, any sequence of M union and find operations will touch the array at most a c (N + M lg star N) times. 现在，lgn是一个有趣的函数。  And now, lg N is kind of a funny function. 它是取log N得到1的次数。  It's the number of times you have to take the log of N to get one. 我们可以这样想，它被称为迭代对数函数。  And the way to think, it's called the iterated log function. 在现实世界中，最好把它看成一个小于5的数因为lg2 ^ 65536等于5。  And in the real world, it's best to think of that as a number less than five because lg two^ 65536 is five. 因此，这意味着带路径压缩的加权快速合并的运行时间在现实世界中是线性的，实际上可以改进为一个更有趣的函数，称为Ackermann函数，它的增长速度甚至比lg<i>慢。  So, that means that the running time of weighted quick union with path compression is going be linear in the real world and actually could be improved to even a more interesting function called the Ackermann function, which is even more slowly growing than lg<i>. 关于这一点的另一点是it&lt;  And another point about this is it&lt; / i&gt;  /i&gt; 似乎这是</i>如此接近于线性，以至于t与N成正比而不是时间与N乘以N中的缓慢增长函数成正比。有没有一个简单的线性算法?  seems that this is</i> so close to being linear that is t ime proportional to N instead of time proportional to N times the slowly growing function in N. Is there a simple algorithm that is linear? 人们为此研究了很长时间，实际上我们可以证明不存在这样的算法。  And people, looked for a long time for that, and actually it works out to be the case that we can prove that there is no such algorithm. 我们使用的算法背后有很多理论。  So, there's a lot of theory that goes behind the algorithms that we use. 对我们来说，了解这个理论很重要，这将帮助我们决定如何选择在实践中使用的算法，以及在哪里集中精力寻找更好的算法。  And it's important for us to know that theory and that will help us decide how to choose which algorithms we're going to use in practice, and where to concentrate our effort in trying to find better algorithms. Friedman和Sachs最终证明了一个令人惊讶的事实，即没有线性时间算法可以解决并集查找问题。  It's amazing fact that was eventually proved by Friedman and Sachs, that there is no linear time algorithm for the union find problem. 但是在实践中，加权快速合并与路径压缩是非常接近的，它将能够解决巨大的问题。  But weighted quick union with path compression in practice is, is close enough that it's going to enable the solution of huge problems. 以上就是我们对解决动态连接问题的算法的总结。  So, that's our summary for algorithms for solving the dynamic connectivity problem. 通过使用加权快速合并和路径压缩，我们可以解决其他方式无法解决的问题。  With using weighted quick union and with path compression, we can solve problems that could not otherwise be addressed. 例如，如果你有10亿个操作和10亿个对象，这可能需要30年的时间。  For example, if you have a billion operations and a billion objects I said before it might take thirty years. 我们可以在六秒钟内完成。  We can do it in six seconds. 现在，最重要的是要认识到，是算法设计使问题的解决方案成为可能。  Now, and what's most important to recognize about this is that its the algorithm design that enables the solution to the problem. 更快的计算机也帮不上什么忙。  A faster computer wouldn't help much. 你可以在一台超级计算机上花费数百万，也许你可以在6年内完成，而不是30年，或者2个月，但用快速对数，你可以在几秒内完成，在你自己的电脑上。
  You could spend millions on a super computer, and maybe you could get it done in six years instead of 30, or in two months but with a fast logarithm, you can do it in seconds, in seconds on your own PC.
:添加到选择中。 : Added to Selection. 按[CTRL + S]保存为笔记
  Press [CTRL + S] to save as a note
(必需)
 (Required)
在
 en
​ ​